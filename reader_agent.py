import json
import time
from typing import Dict, Any, Optional
from llm_validator import LLMValidator


# JSON schema used to validate the plan generated by the ReaderAgent
PLAN_SCHEMA = {
    "type": "object",
    "properties": {
        "framework": {"type": "string"},
        "language": {"type": "string"},
        "llm": {"type": "string"},
        "embedding_model": {"type": "string"},
        "components": {"type": ["object", "array"]},
        "termination_policy": {"type": "object"},
        "files": {"type": ["array", "null"]}
    },
    "required": ["framework", "language", "llm", "components"]
}


class ReaderAgent:
    """
    Reader Agent (Autonomous Dynamic System Planner)
    ------------------------------------------------
    - Consumes Enhanced Prompt (from DynamicPromptNode)
    - Lets the LLM invent its own architecture dynamically
    - Avoids static archetypes like ReaderAgent/WriterAgent/ValidatorAgent
    - Produces a validated plan that the Writer Agent can consume
    """

    def __init__(self, llm_client, validator: LLMValidator, max_retries: int = 2, retry_delay: float = 0.8):
        self.llm = llm_client
        self.validator = validator
        self.max_retries = max_retries
        self.retry_delay = retry_delay

    def _build_plan_prompt(self, enhanced_prompt: str) -> str:
        """Construct the prompt that will guide the LLM to create a structured architecture plan."""
        return f"""
You are the Reader Agent, a master autonomous system architect.

Your mission:
Design a complete intelligent architecture for the user's described goal.
Invent agents, modules, or nodes that make sense logically and contextually.

Requirements:
1. Do NOT use generic names like ReaderAgent, WriterAgent, ValidatorAgent, ImproverAgent, or CoordinatorAgent.
2. Invent meaningful, domain-specific component names.
3. Each component must define:
   - name
   - description
   - inputs
   - outputs
   - dependencies
4. You can return "components" as either:
   - an object (key-value map), OR
   - an array of objects (each having a "name" field)
5. Choose a suitable framework (LangGraph, CrewAI, LlamaIndex, AutoGen, etc.)
6. Use Python only.
7. Include a "termination_policy" (rules or max_steps).
8. Optionally include a "files" list.

Output Format Rules:
- Return one valid JSON object only.
- Must contain fields: ["framework", "language", "llm", "embedding_model", "components", "termination_policy", "files"]

Enhanced Prompt:
{enhanced_prompt}

Return only JSON below.
""".strip()

    def _parse_json(self, text: str) -> Optional[Dict[str, Any]]:
        """Attempt to safely parse JSON, even if surrounded by non-JSON text."""
        try:
            return json.loads(text)
        except Exception:
            start, end = text.find("{"), text.rfind("}")
            if start != -1 and end != -1 and end > start:
                try:
                    return json.loads(text[start:end + 1])
                except Exception:
                    return None
            return None

    def _normalize_components(self, components):
        """Ensure components are always represented as a dictionary."""
        if isinstance(components, dict):
            return components

        if isinstance(components, list):
            normalized = {}
            for c in components:
                name = c.get("name") if isinstance(c, dict) else None
                if name:
                    normalized[name] = {k: v for k, v in c.items() if k != "name"}
            return normalized

        return {}

    def plan_from_prompt(self, enhanced_prompt: str, instruction: Optional[str] = None) -> Dict[str, Any]:
        """
        Main pipeline that uses the LLM to create an autonomous plan.
        It validates each response and retries when structure or fidelity issues occur.
        """
        prompt = self._build_plan_prompt(enhanced_prompt)
        attempts = 0
        last_error = None

        while attempts <= self.max_retries:
            attempts += 1
            print(f"Attempt {attempts}: Asking LLM for architecture plan.")
            try:
                llm_resp = self.llm.invoke(prompt)
                content = getattr(llm_resp, "content", None) or getattr(llm_resp, "text", None) or str(llm_resp)
                plan_candidate = self._parse_json(content)

                if plan_candidate is None:
                    last_error = "Invalid or non-JSON response."
                    print("JSON invalid, retrying...")
                    time.sleep(self.retry_delay)
                    continue

                # Normalize components if the model returned a list
                if "components" in plan_candidate:
                    plan_candidate["components"] = self._normalize_components(plan_candidate["components"])

                # Structural schema validation
                v_report = self.validator.validate_response(
                    response_text=json.dumps(plan_candidate),
                    expected_schema=PLAN_SCHEMA,
                    instruction=instruction or "Autonomous system plan generation",
                    require_json=True,
                    run_llm_check=False
                )

                if v_report.get("status") == "fail":
                    last_error = f"Schema invalid: {v_report.get('issues')}"
                    print("Schema validation failed, retrying...")
                    time.sleep(self.retry_delay)
                    continue

                # Deep validation using LLM check
                v_report_full = self.validator.validate_response(
                    response_text=json.dumps(plan_candidate),
                    expected_schema=PLAN_SCHEMA,
                    instruction=instruction or "Autonomous system plan generation",
                    require_json=True,
                    run_llm_check=True
                )

                if v_report_full.get("status") == "fail":
                    last_error = f"LLM validator rejected plan: {v_report_full.get('issues')}"
                    time.sleep(self.retry_delay)
                    continue

                # Reject generic placeholder names
                bad_names = ["readeragent", "writeragent", "validatoragent", "improveragent", "coordinatoragent"]
                comp_names = [n.lower() for n in plan_candidate.get("components", {}).keys()]
                if any(b in n for n in comp_names for b in bad_names):
                    print("Generic agent names detected, requesting a more creative plan.")
                    time.sleep(self.retry_delay)
                    continue

                print("Architecture plan validated successfully.")
                return {
                    "success": True,
                    "plan": plan_candidate,
                    "validation_report": v_report_full,
                    "attempts": attempts,
                    "error": None
                }

            except Exception as e:
                last_error = str(e)
                print(f"Exception during planning: {last_error}")
                time.sleep(self.retry_delay)
                continue

        print("Failed to generate a valid autonomous plan after retries.")
        return {
            "success": False,
            "plan": None,
            "validation_report": None,
            "attempts": attempts,
            "error": last_error or "unknown"
        }
